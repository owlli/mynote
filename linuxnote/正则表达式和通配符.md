# 正则表达式和通配符

正则表达式和通配符不是同一个概念,不要混淆,但它们部分符号代表的含义相同,通配符是bash操作界面的一个功能,比如ls不支持正则表达式但是支持[],*,?等通配符的使用.支持正则表达式的命令有grep,sed,awk等

[TOC]



## 1.通配符

### 1.常用的通配符

`*`		代表0到无穷多的任意字符，注意：文件名前的.和路径中的/必须显式匹配

`?`		代表一定有一个任意字符

`[]`		代表一定有一个中括号内的字符，比如[abc]代表一定有一个字符是abc中的任意一个，注意：前面介绍的*和?如果在中括号内就失去通配符的意义
`[-]`	-号的两边为数字或字母，比如[0-9]、[a-z]，和上面意义相同

`[^]`或`[!]`	代表一定有一个字符，只要不是^/!号后面的字符就可以



### 2.shell下通配符转换方式的理解

以

```shell
ls [a-z]*
```

为例,

shell先对通配符进行匹配，如果没有匹配项则直接查找文件名为'[a-z]*'的文件



## 2.正则表达式

在正则表达式中
`.`		代表一定有一个字符

`*`		前面必须有一个字符，代表重复前一个字符0到无穷多次，和`{0,}`相同,如果是0就是空字符

`+`		前面必须有一个字符,代表重复前一个字符1到无穷多次,和`{1,}`相同

`?`		重复前面字符0次或1次,和`{0,1}`相同,还可以表示非贪心匹配,比如有字符串a==b===b====b,`a.*b`匹配的是a==b===b====b,`a.*?b`匹配的是a==b

`[]`		代表一定有一个中括号内的字符，比如[abc]代表一定有一个字符是abc中的任意一个,[]里的()会被当做普通字符处理

`[-]` 	-号的两边为数字或字母，比如[0-9]、[a-z]，和上面意义相同

`[^]`	代表一定有一个字符，只要不是^号后面的字符就可以

`()`		将括号内的字符串当做一个整体,字符串不需要加双引号,里面的字符串是一个整体,比如(ab){1,3}代表匹配ab这个字符串1到3次

`(|)`	匹配多个字符串,每个字符串用|隔开

正则表达式有3种,每种使用转义字符和语法略有不同:

1. 基本的正则表达式(Basic Regular Expression 又叫 Basic RegEx  简称 BREs)
2. 扩展的正则表达式(Extended Regular Expression 又叫 Extended RegEx 简称 EREs)
3. Perl 的正则表达式(Perl Regular Expression 又叫 Perl RegEx 简称 PREs)

**`grep`和`find -iregex`默认是使用BREs,在(),|,+符号前加\转义才有效,否则命令解析时会把(),|当做普通字符处理**

`^`		行首之前的字符，在行处理的正则表达式中也代表最前一行

`$`		行尾之后的字符，在行处理的正则表达式中也代表最后一行

`{}`		花括号内必须有一个数字或用,号隔开的多个数字，数字代表前一个字符出现的次数，如果只有一个数字n且在其后加了,号，代表匹配n个此字符及n以上个此字符，因为在shell中{}具有特殊含义，所以在正则表达式中需要在花括号前加转义字符\，例子如下：

> `\{n\}`	匹配前面字符出现n次
>
> `\{n,\}`	匹配前面字符至少出现n次
>
> `\{n,m\}`	匹配前面字符出现n~m次

`\s`		空格

`\S`		非空格

`\d`		数字

`\D`		非数字

`\w`		字符(字母,数字,下划线)

`\W`		非字符

### 1.正则表达式的特殊符号

因为字符编码的不同，不同语系会造成正则表达式获取资料的差异，因此建议用特殊符号代替编码范围

> 特殊符號		代表意義
>
> [:alnum:]	代表英文大小寫字元及數字，亦即 0-9, A-Z, a-z
>
> [:alpha:]		代表任何英文大小寫字元，亦即 A-Z, a-z
>
> [:blank:]		代表空白鍵與 [Tab] 按鍵兩者
>
> [:cntrl:]		代表鍵盤上面的控制按鍵，亦即包括 CR, LF, Tab, Del.. 等等
>
> [:digit:]		代表數字而已，亦即 0-9
>
> [:graph:]		除了空白字元 (空白鍵與 [Tab] 按鍵) 外的其他所有按鍵
>
> [:lower:]		代表小寫字元，亦即 a-z
>
> [:print:]		代表任何可以被列印出來的字元
>
> [:punct:]		代表標點符號 (punctuation symbol)，亦即：" ' ? ! ; : # $...
>
> [:upper:]		代表大寫字元，亦即 A-Z
>
> [:space:]		任何會產生空白的字元，包括空白鍵, [Tab], CR 等等
>
> [:xdigit:]		代表 16 進位的數字類型，因此包括： 0-9, A-F, a-f 的數字與字元

[:alnum:],[:alpha:],[:digit:],[:lower:],[:upper:]为常用

**因为它们代表的只是 0-9 这样的字符，所以在使用的时候一定要用中括号括起来，如[[:digit:]]**



### 2.支撑正则表达式的命令

#### 1.sed

> 选项
> -n		使用安靜(silent)模式。在一般 sed 的用法中，所有來自 STDIN 的資料一般都會被列出到螢幕上。但如果加上 -n 參數後，則只有經過 sed 特殊處理的那一行(或者動作)才會被列出來
>
> -e		默认启用，直接在命令上进行编辑，如果一个sed命令中有两个以上的动作，在每个动作前都要加-e（理解为直接对从管道后获得的标准输入进行处理）
>
> -f file	file为sed动作的文本文件，动作里不需要'"单双引号，sed执行file中的sed动作
>
> -i		直接修改文件而不是标准输入
>
> -r		使用扩展的正则表达式语法(默认是基本的正则表达式语法)
> 动作
>
> d		删除	'2,5d' 删除2到5行	'2d' 删除第二行	'3,$d' 删除3到最后一行	'/^$/d' 删除空白行
>
> a str	向下新增	'2a drink tea' 在第二行下增加	'2a drink tea\回车drink beer' 在第二行下新增两行
>
> i str		向上插入	和a一样用
>
> p		打印，一般和sed -n连用	sed -n '5,7p' 打印出第5到7行
>
> c str	替换行	'2,5c No 2-5 number' 将第2到5行替换为这个字符串
>
> s		替换字符	sed 's/要被取代的字串/新的字串/g'

#### 2.awk

	awd的功能太强大了,此工具的用法可以写一本书,这里只摘录《鸟哥的linux私房菜中的用法》
	
	awk是以行为单位，处理不同列的工具

> $0	代表一行的字符
>
> $1	代表一行的第一列字符
>
> $2	代表一行的第二列字符
>
> ...
>
> NF	一行拥有的列数
>
> NR	当前的行数
>
> FS	分隔符，默认为空格和tab
>
> BEGIN	第一行
>
> END	最后一行

举例说明:

```shell
last -n 5 | awk '{print $1 "\t" $3}'	#输出last命令的第1、3列字符
last -n 5| awk '{print $1 "\t lines: " NR "\t columns: " NF}'	#输出第一列字符及行号和每行的列数
cat /etc/passwd | awk '{FS=":"} $3 < 10 {print $1 "\t " $3}'	#以:为分隔符，当第三列小于10时，输出passwd文件的的第一列及第三列，但是awk中变量的定义应该是从第二行生效
cat /etc/passwd | awk 'BEGIN {FS=":"} $3 < 10 {print $1 "\t " $3}'	#和上面一样，但是加入了BEGIN，说明从第一行开始生效
echo a,b,c|awk -F","  '{print $1}'	#以，为分隔符，输出第一个字符
echo "abc" |awk -F "" '{print NF}'	#以空为分隔符，输出字符串长度
echo “Alex”|awk '{print length($0)}'	#输出这一行字符串长度
cat pay.txt
Name    1st     2nd     3th
VBird   23000   24000   25000
DMTsai  21000   20000   23000
Bird2   43000   42000   41000
cat pay.txt | \
> awk 'NR==1{printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total" }
> NR>=2{total = $2 + $3 + $4
> printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
      Name        1st        2nd        3th      Total
     VBird      23000      24000      25000   72000.00
    DMTsai      21000      20000      23000   64000.00
     Bird2      43000      42000      41000  126000.00
#如果在{}内有多步运算，一定要用;或者换行隔开，printf语句中，必须用\n才能换行，awk语句中变量前不需要加$符号
cat pay.txt | \
> awk '{if(NR==1) printf "%10s %10s %10s %10s %10s\n",$1,$2,$3,$4,"Total"}
> NR>=2{total = $2 + $3 + $4
> printf "%10s %10d %10d %10d %10.2f\n", $1, $2, $3, $4, total}'
#和上面的一个意思

#awk去除文件中的重复行
lzh@lzh-ws:test$ cat dup 
hello world
awk
coding ants
hello world
awk
hello world
awk
coding ants
coding ants
lzh@lzh-ws:test$ awk '!a[$0]++' dup
hello world
awk
coding ants
#在<awk程序指令模型>中介绍了awk的程序指令由模式和操作组成，即Pattern { Action }的形式，如果省略Action，则默认执行print $0的操作,这里的Pattern就是"!a[$0]++",这里没有定义Action,所以这里Action就是print $0
#在awk中，对于未初始化的数组变量，在进行数值运算的时候，会赋予初值0，因此a[$0]=0，++运算符的特性是先取值，后加1，因此Pattern等价于!0,即为1,所以默认执行print $0
#之后a[$0]就等于1了,所以,遇到相同行,a[$0]就为正数,!a[$0]++就为假,就不会执行print $0了

#统计文本里第三列出现的次数,并以输出结果的第一列排序
cat txt | awk '{a[$3]++}END{for(i in a){print i,a[i] | "sort -k 1"}}'
```

#### 3.printf

字符打印命令，用法和c语言中类似

例子:

```shell
printf '%10s %5i %5i %5i %8.2f \n' $(cat printf.txt | grep -v Name)
```



### 3.扩展正则表达式

#### 1.egrep

等于grep -E，grep不支持扩展正则表达式

ER字符	意义

`+`		重复一个或一个以上前一个字符

`?`		0个或1个前一个字符

`|`		or（或）	egrep -n 'gd|good' regular_express.txt

`()`		找出群组字符串	egrep -n 'g(la|oo)d' regular_express.txt

`()+`	多个重复字符串	echo 'AxyzxyzxyzxyzC' | egrep 'A(xyz)+C'



### 4.默认不支持正则表达式的命令使用支持正则表达式的选项

find命令的-name选项后的参数,是不支持正则表达式的,可以使用-iregex选项,后面跟的字符串就可以支持正则表达式





## 参考连接

[awk使用案例：通过awk去除重复行](http://www.letuknowit.com/topics/20120401/use-awk-remove-duplicate-lines.html/)