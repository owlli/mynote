# 服务,端口,进程,内存和系统资源常见的查看和管理方法



## 服务和端口的查看和管理

这里仅介绍sysvinit初始化系统的服务管理方式,systemd初始化系统的介绍请看我的<systemd介绍及使用>文章,这里不再赘述

### 服务器启动/停止/查看状态方法

```shell
service 服务名 start/stop/status
/etc/init.d/服务名 start/stop/status	#推荐这种,因为可以用tab键自动补全
```

### 查看服务开机是否启动

```shell
chkconfig --list 服务名
chkconfig --list | grep 服务名
```

### 设置服务在各启动模式下是否启动

```shell
chkconfig 服务名 on/off
#选项：--level 启动模式 默认为3、5
```

### 查看系统中常见服务和对应的端口号

```shell
cat /etc/services
```

### 查看服务所占端口

```shell
netstat -ntupl | grep 服务名/端口号
```

netstat命令用来查看系统已打开端口,常用选项如下:

> -l	仅列出正在监听（listen）的服务
> -a	列出目前系统上所有联机、监听、socket的数据
> -t	列出tcp网络封包数据
> -u	列出udp网络封包数据
> -n	不易服务名称，以端口号来显示
> -p	列出网络服务的程序的pid



## 进程的查看和管理

### 进程和线程的查看

```shell
ps aux	#或者 ps -el
ps aux	#观察系统所有的程序数据,可以看进程开始时间，cpu、内存占用率
ps -el	#可以看进程ppid，可以看priority和nice
ps axj	#查看进程的详细信息
ps axf	#可以看到进程树
ps axm	#可以看和线程相关的信息
```

ps命令的常用选项如下:

> -A :所有的 process 均显示出来,不 -e 具有同样的效用;
> -a :不与 terminal 有关的所有 process ;
> -u :有效使用者 (effective user) 相关的 process ;
> x :通常与 a 这个参数一起使用,可列出较完整信息。
> 输出格式规划:
> l :较长、较详细的将该 PID 的信息列出;
> j :工作的格式 (jobs format)
> -f :做一个更为完整的输出

```shell
pidof 进程名称	#查看此进程的pid号
```

查看线程的信息并以cpu占用率倒序排序

```shell
ps H -eo user,pid,ppid,tid,time,%cpu,cmd --sort=%cpu
```

查看进程的工作目录

```shell
pwdx 进程号
```

查看进程的完整进程名

```shell
cat /proc/进程号/cmdline
```



### 进程后台执行

在终端下执行的命令都是当前终端的自进程，若想在当前终端注销后依然可以执行（除守护进程），可以用at、crontab或nohup

#### 进程后台挂起

如果一个进程正在终端执行,可以按`ctrl+z`将此进程在后台挂起.如果想将当前shell在后台挂起,可以执行`suspend`命令

#### 进程后台执行的方法

1. 在命令后加入&符号.

   命令在后台执行,不占用shell的屏蔽了SIGINT信号,但是没有屏蔽SIGHUP信号,所以当所在shell关闭时,此进程也自动关闭

   > shell特殊变量$!代表上一个后台命令对应的进程号

2. nohup 命令.不支持bash内建命令,标准输出为此命令的目录下的nohup.out文件,如果当前目录的 nohup.out 文件不可写,输出重定向到 $HOME/nohup.out 文件中.

   屏蔽了SIGHUP信号,但是没屏蔽SIGINT信号,占用shell终端,所以如果执行ctrl+c,会将此进程杀死

3. nohup 命令 &.命令在后台执行,相当于守护进程,屏蔽了SIGHUP和SIGINT信号

4. 在终端执行程序时按ctrl+z，可以将此程序放到后台暂停

#### 查看和管理后台执行的进程

```shell
jobs
#查看后台进程，-l选项可以查看后台进程pid，jobs的结果中最前面是后台进程号（不同于进程号），+号代表最后一个暂停的后台进程，-号代表倒数第二个暂停的后台进程
bg %n
#n代表后台进程号，让后台进程n在后台继续运行，部分后台进程无法在后台运行，比如vim、top。如果没有%n，即代表最后一个暂停的进程，即带+号的进程，执行后倒数第二个暂停的进程带+号，倒数第三个暂停的进程带-号，依次类推，可省略%号
fg %n
#n代表后台进程号，让后台进程n放到前台运行。如果没有%n，即代表最后一个暂停的进程，即带+号的进程，执行后倒数第二个暂停的进程带+号，倒数第三个暂停的进程带-号，依次类推，可省略%号
kill -n %n	#n（第一个）代表kill的sign，n（第二个）代表后台进程号，kill掉此后台进程，不可省略%号
wait
#等待当前shell所有后台进程执行完
```

#### 定时任务at和crontab

```shell
at 时间	#执行后输入要执行的命令，在设置的那个时间点就会执行已输入的命令，只执行一次
batch 时间	#和at一样，只不过是当到达那个时间点后，cpu负载小于0.8时才执行此任务
atq	#查看at任务
atrm n	#删除n号at任务
```

```shell
crontab -u 用户名 -e	#编辑crontab任务，若编辑自己的可不加-u，root用户可以为其他用户编辑crontab，下同，内容格式为“分 时 日 月 周 命令绝对路径名”，日和周不能同时使用
crontab -u 用户名 -l	#查看crontab任务
crontab -u 用户名 -r	#删除此用户所有crontab任务，如果只删除一条用-e编辑
```

### 进程的管理

```shell
kill -l	#查看系统中信号种类
kill -n pid	#n代表信号种类,默认为15
killall -n 进程名
```

## 系统资源的查看

### top命令

top命令常见选项如下:

> -d n	后面加数字代表top刷新时间，单位为s，默认为3
> -p n	后面加pid，代表检测某个进程，一个-p选项能设置一个pid，可以再后面再加-p选项检测多个进程
> -b 	以批次的方式输出top的结果，一般在后面加重定向到某个文件
> -n n	代表top更新次数，可与-b搭配，代表进行几次top输出结果
> -c	完整显示进程绝对路径名和参数（COMMAND列）

在top界面,可以按键操作:

> ？/h	显示在top中可以输入的按键指令（应该不全，比如下面的指令没有）
> 1	观察每个逻辑cpu状态信息
> P	以cpu的使用资源排序显示
> M	以memory的使用资源排序显示
> N	以pid来排序
> f/F	设置进程要显示的列
> y	加粗显示正在运行进程的那一行，即S列为R
> x	加粗显示排序依据的那一列
> b	高亮显示加粗的行和列
> shift + </>	左/右移动排序依据的那一行
> T	以进程使用的cpu时间累计（TIME+）排序
> s	改变两次刷新之间的延迟，单位为s，如果为小数就换算成ms，如果为0就不断闪动刷新
> c	完整显示进程绝对路径名和参数（COMMAND列）
> k	给予某个pid一个讯号（signal），即kill
> r	给予某个pid新的nice值
> m	切换内存使用信息的显示方式
> t	切换cpu使用信息的显示方式
> W	将当前设置写入~/.toprc文件中

top界面内容介绍:

> 第一行
> 同 uptime 命令的执行结果，具体参数说明情况如下：
> 当前系统时间	系统已经运行时间（即开机时间）	用户数量（包括未登陆shell）	cpu负载（load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况）	
>
> 第二行为进程数量统计
>
> 第三行为cpu状态信息，详细说明如下：
> us	用户空间占用cpu的百分比
> sy	内核空间占用cpu的百分比
> ni	改变过nice值的进程占用cpu百分比
> id	空闲cpu百分比
> wa	IO等待占用cpu的百分比
> hi	硬中断占用的cpu百分比
> si	软中断占用的cpu百分比
> st	被虚拟机盗用的cpu使用状态
> 一般主要看id和wa

### cpu负载和利用率

**cpu负载和利用率不是同一个概念!**

cpu负载指cpu工作量和cpu支持的最大工作量的比例.

如果CPU每分钟最多处理100个进程，那么系统负荷0.2，意味着CPU在这1分钟里只处理20个进程；系统负荷1.0，意味着CPU在这1分钟里正好处理100个进程；系统负荷1.7，意味着除了CPU正在处理的100个进程以外，还有70个进程正排队等着CPU处理.

如果cpu负载长时间大于(cpu线程数*0.7),建议检查系统或升级硬件

cpu利用率指cpu工作时,cpu的繁忙程度,cpu的工作状态分为用户态,系统态,空闲态等,cpu利用率=(1-空闲态工作时间)/cpu总工作时间

对于top命令打印的单个进程的cpu利用率理解:如果cpu时间片轮转到某个线程时,需要cpu持续计算,那cpu利用率就很高,轮转到某个线程时,需要等待io资源,或者只需要少量计算,那cpu利用率就低

### nice值

普通用户只能把进程的nice值调高,只有root用户才能把nice值调低

```shell
nice -n n 命令	#启动一个新进程并设置nice值为n
renice n 命令		#调整一个进程nice值
```

nice值可以被子进程继承

实际原始priority由内核根据实际情况设定,所有有时改了nice值后,priority值不会有对应数值的变化.在ps -el和top命令中看到的PRI即为实际的priority

### 查看内存

free命令

> 默认以Kbytes为单位
> -m	以Mbytes为单位
> -g	以Gbytes为单位
> -t	查看内存+swap总量

一般free命令的free列出的为扣除buff（ers）和cache的内存，实际可用内存要在此基础上减去buff和cache，buff是待写入硬盘的缓存，cache为读取到内存的缓存，因为linux内核的特性，系统会不断地增加buff和cache以加快系统速度

### vmstat

```shell
vmstat n1 n2	#每n1秒更新一次,共更新n2次
```

vmstat常用选项如下:

> -S	改变数据的单位，默认以K为单位，可改为M
> -p 分区绝对路径名	侦测此分区数据读写总量	
> -d	列出磁盘的读写总量统计

vm打印结果介绍:

> 第一列(procs) ：
> r ：等待运行中的程序数量；b：不可被唤醒的程序数量。这两个项目越多，代表系统越忙碌 (因为系统太忙，所以很多程序就无法被运行或一直在等待而无法被唤醒之故)。
> 第二列(memory)：
> swpd：虚拟内存被使用的容量； free：未被使用的内存容量； buff：用於缓冲内存； cache：用於高速缓存。这部份则与 free 是相同的。
> 第三咧(swap)：
> si：由磁碟中将程序取出的量； so：由於内存不足而将没用到的程序写入到磁碟的 swap 的容量。如果 si/so 的数值太大，表示内存内的数据常常得在磁碟与主内存之间传来传去，系统效能会很差！
> 第四列(io)：
> bi：由磁碟写入的区块数量； bo：写入到磁碟去的区块数量。如果这部份的值越高，代表系统的 I/O 非常忙碌！
> 第五列(system)：
> in：每秒被中断的程序次数； cs：每秒钟进行的事件切换次数；这两个数值越大，代表系统与周边设备的沟通非常频繁！这些周边设备当然包括磁碟、网络卡、时间钟等。
> 第六列（CPU）：
> us：非核心层的 CPU 使用状态； sy：核心层所使用的 CPU 状态； id：闲置的状态； wa：等待 I/O 所耗费的 CPU 状态；st：被虚拟机器 (virtual machine) 所盗用的 CPU 使用状态 (2.6.11 以后才支持)。

### 查看正在使用文件或文件系统的进程

fuser

fuser常用选项如下:

> -u	除了程序的 PID 之外，同时列出该程序的拥有者
> -m	后面接的那个档名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效
> -v	可以列出每个文件与程序还有命令的完整相关性
> -k	找出使用该文件/目录的 PID ，并试图以SIGKILL这个讯号给予该 PID
> -i	必须与 -k 配合，在删除 PID 之前会先询问使用者意愿

解决u盘无法卸载方法(device is busy):

```shell
fuser -mvu u盘挂载目录	#可以找到正在使用此u盘的进程，kill后即可卸载
#也可以直接fuser -mki u盘挂载目录，直接提示是否kill掉此进程
```

### 查看正在使用某端口的进程

```shell
lsof -i:22	#查看占用22端口的进程
```











