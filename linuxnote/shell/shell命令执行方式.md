# shell命令执行方式

管道符,重定向,逻辑判断



## shell命令解析过程

1. 替换变量
2. 执行命令
3. 使用按IFS划分命令之后的参数,用''或""包围的部分作为命令的一个参数

举例见<<shell.md>>中的"echo不显示变量中的多个空格?"



## shell命令查找顺序

1.以相对/绝对路径执行指令，例如`/bin/ls`或`./ls`;

2.由 alias 找到该指令来执行;

3.由 bash 内建的 (builtin) 指令来执行;

4.透过 $PATH 这个变数的顺序搜寻到的第一个指令来执行.

> 可通过type -a 指令名来查找一个指令是别名还是内建指令还是外部指令



## 通配符转换方式的理解

```shell
lzh@lzh-ws:aaa$ ls [a-z]*
ls: cannot access '[a-z]*': No such file or directory
```

上面命令执行原理是先对通配符进行匹配，如果没有匹配项则直接`ls [a-z]*`，提示没有名为`[a-z]*`文件



## 重定向

### 重定向的执行方式

首先判断>符号后面的文件是否存在,如果不存在立即创造,如果存在重定向会将原来的文件删除并新建一个空的,追加不会删除原来存在的文件

`>`、`>>`符号右边必须是字符或者是文本文件名

`<<`的作用

例子:

```shell
cat << EOF
#输入一些字符，直到在一行输入EOF后回车，自动结束输入,对于某些需要互动输入的命令,可以通过追加符来取消互动输入
```

```shell
#!/bin/bash
update-alternatives --config java << EOF
2
EOF
```

回车或以;结尾的一句语句是一条命令,如果语句中有管道或者重定向/追加符|、>、>>、<、<<它们也都是一条语句,他们都会被执行,例子：

```shell
ps aux | grep os
#执行完后,结果中一定有grep os进程
test.sh > err1 2>err2
#test.sh是一个脚本,其中有正确的shell命令和不正确的shell命令.执行完后，test.sh中正确的shell命令反馈结果保存在err1文件中，错误的shell命令结果保存在err2中，并不会因为>过滤了正确的内容导致2>收不到错误的内容
grep "abc" test.txt > test.txt
#最终test.txt为空，包含输出重定向>的命令中，第一步是检测右边文件是否存在，存在就删除新建一个空文件，不存在就新建空文件，删除后新建的空文件中没有abc字符，所以grep无法查询到结果
```



## 管道

只有过滤器命令可以通过管道接受左边传来的东西，如果不是过滤器命令，可以在命令前加一个xargs



## 或且运算符&& || 

例子:

```shell
命令1||命令2&&命令3
```

先检测左边,如果命令1失败了,再执行命令2,命令2执行成功了命令3也执行.

如果命令1执行成功了,命令2不执行,命令3会执行,因为对于&&来说,前面的结果是真







