# shell



## shell选项

查看shell的选项配置

```shell
set -o
```

或者

```shell
echo $-
```

set -/+参数改选项，-为加配置，+为减配置。一般为以下字符:

> H - history expand	可用!+数字直接执行历史中的命令。
>
> B - brace expansion	可用“touch 文件名{1..5}”来创建文件。
>
> m - monitor mode	job control，可用ctrl+z或ctrl+c控制shell中正在显示的进程。
>
> h - hashall		缓存执行过的命令的路径，比如将/bin/下的命令移动到/usr/local/bin下，短时间内命令将不能执行。
>
> 额外的介绍
>
> u	默认不启用，启用后使用未赋值的变量时，会显示错误信息（变量赋值了就算是空值不会报错）
>
> v	默认不启用，启用后命令结果输出时，第一行会显示命令原句（ubuntu14使用Tab补全功能时会输出很长一串字符，不理解）
>
> x	默认不启用，启用后命令结果输出时，第一行就显示命令，前面有+号，如果是别名会显示原始名，如果是变量会显示变量的值（ubuntu14使用Tab补全功能时会输出很长一串字符，不理解）
>
> C	默认不启用，启用后使用>重定向，若文件已存在将不会被覆盖
>
> e	表示一旦脚本中有命令的返回值为非0，则脚本立即退出，后续命令不再执行
>
> a	被创建或修改的变量自动变为环境变量

set也可以给当前shell设置位置参数,例子:

```shell
lzh@lzh-ws:test$ set abc def
lzh@lzh-ws:test$ echo $1 $2
abc def
```



## shell分类

### 登录式shell和非登录式shell

在shell下输入

```shell
echo $0
```

如果是bash则为非登录shell，如果是-bash则为登录shell

* 登录式shell:

进入方式:输入帐号密码的形式，比如开机登录、su -（不是su）、ctrl+alt+Fx

配置文件加载流程:登录后读取/etc/profile文件并执行，然后按顺序查找~/.bash_profile， ~/.bash_login，或者~/.profile，读入第一个存在的文件并执行，可能通过指定--noprofile参数来禁止这种默认行为，当登录Shell退出之后，会读取~/.bash_logout文件并执行。

* 非登录式shell

进入方式:不用输入帐号密码的形式，比如在图形桌面下打开的terminal、su（不是su -）、konsole、bash命令打开的shell

配置文件加载流程:打开后读取~/.bashrc文件中定义的命令，可以在执行bash时加--norc参数来禁止该行为，或者通过--rcfile指定其它文件。



很多linux发行版里都把profile或bashrc等环境配置脚本写到bash_profile或者图形桌面的配置文件比如/etc/gdm/Xsession中,只要启动了图形桌面,这些配置文件就自动加载了



### 分交互式shell和非交互式shell

在shell下输入

```shell
echo $-
```

如果是himBH，包含i，则是交互式，如果不包含i，则是非交互式shell

* 交互式shell

根据手动输入命令终端解析后返回结果的

* 非交互式

执行一个脚本时分配的子shell，可用“bash -c 'echo $-'”实验



## shell中的特殊符号

`#`	代表注释，一般用在script中
`\`	转义字符，除在单引号中，其他地方如果想表示此符号要\\
`|`	管道
`;`	命令分隔符
`~`	使用者家目录
`$`	使用变量时加在变量名前面
`&`	将指令放到后台执行
`!`	非
`/`	目录符号
`>,>>`	重定向
`<,<<`	重定向
`''`	单引号，其中所有内容都作普通字符，**在正则表达式中无效(如果一条命令的参数是正则表达式,即使这条参数字符串是用 ' 框起来的, ' 里面的字符依旧作为正则表达式中的字符处理,比如`grep '[abc]' ./ -R`,`sed '^a' xxx`这些命令,虽然使用了 ' 符号,但[]和^仍做特殊符号处理)**
`""`	双引号，除$、\、`三个符号外都作普通字符

` `` `	倒引号，代表一个指令的值

### 花括号和括号用法

#### 花括号用法

* 组合命令

```shell
{ 命令;}
```

> 里面的命令以分号;或回车隔开
>
> 左花括号{后面必须有一个空格，右花括号}之前必须有一个分号;
>
> 此方式只是在本shell内执行命令

* 变量

下面所有操作只会打印一些字符串,并不会改变变量的值!!!

```shell
${变量}
为了把某个变量和后面的字符区分开
如:
dir=aaa
echo ${dir}ectory
如果脚本或命令的实参数大于9,表示第9个参数可以用$9,表示第10个参数时必须用${10}

${#str}
获取字符串长度

${数组名[*]}和${数组名[@]}都表示数组中所有非空元素，每个元素值用空格分开，如果用双引号把它们括起来，那么区别是：
"${数组名[*]}"	被扩展成一个字符串，每个元素以空格分开
"${数组名[@]}"	被扩展成多个词，每个数组元素都是一个词

${数组变量[下标]}
表示数组变量的一个元素
${#数组变量[下标]}
表示此元素值的长度（字符个数）

${变量#字符}
如果字符和变量开头匹配，返回值为去掉此字符开头的变量（支持通配符），去掉部分是与字符匹配最少的。
${变量##*字符}
去掉变量中从左侧数最后一个与此字符相匹配的字符，去掉部分是与字符匹配最多的。
${变量%字符}
如果字符和变量末尾匹配，返回值为去掉此字符末尾的变量（支持通配符），去掉部分是与字符匹配最少的。
${变量%%字符*}
去掉变量中从右侧数最后一个与此字符相匹配的字符，去掉部分是与字符匹配最多的。
记忆方法：#在$左边，所以从左匹配，%在$右边，所以从右匹配。
${变量/旧字符/新字符}
如果变量中含有符合旧字符,则第一个旧字符串会被新字符串替换
${变量//旧字符/新字符}
如果变量中含有符合旧字符,则所有旧字符串会被新字符串替换
${变量/#旧字符/新字符}
如果字符串变量在开头匹配旧字符,则开头的旧字符串会被新字符串替换
${变量/%旧字符/新字符}
如果字符串变量在末尾匹配旧字符,则末尾的旧字符串会被新字符串替换

${#name[*]}和${#name[@]}
数组元素的个数,只要元素值被赋值过,就算某个元素的值被赋值为空也会计入

${变量名:position}
从变量字符串中的第'position'位置开始抽取字符到字符串变量尾部,字符串的第一个字符为0位置
${变量名:position:length}
从变量字符串中的第'position'位置开始抽取'length'个字符,字符串的第一个字符为0位置

${变量名: -position},${变量名:(-position)},${变量名: (-position)}
从变量字符串中的倒数第'position'位置开始抽取字符到字符串变量尾部,字符串的倒数第一个字符为1位置
同理,可以使用${变量名: -position:length}这种方式
```

* 构造序列

```shell
#来顺序输出0到10这11个数
echo {0..10}
#倒序输出
echo {10..0}
#跳过其中的奇数倒序输出
echo {10..0..2}
#倒序输出字母表
echo {z..a..2}
#其他使用方法以此类推
#还可以将两个序列进行组合,下面这个命令会将从aa到zz的所有双字母组合依次输出
echo {a..z}{a..z}
```

* 大小写转换

> 仅支持4.0以上版本bash

```shell
#把变量中第一个字符转换成大写
${变量名^}
#把变量中的所有小写字母,全部替换为大写
${变量名^^}
#把变量中的第一个字符换成小写
${变量名,}
#把变量中的所有大写字母,全部替换为小写
${变量名,,}
```





#### 圆括号用法

* 组合命令

```shell
(命令)
```

> 里面的命令以分号;或回车隔开
>
> 左括号(后不必加空格，右括号)前不必加分号
>
> 此方式是在一个子shell中执行

* 代表命令

```shell
$(命令)
#和`命令`作用一样
#一般用作变量的赋值

$((整形变量算术运算符整形变量))
#返回值为一个整数，两个括号里可以直接对变量进行数值运算，如果是变量的话可以不加$符来表示变量
```

* 定义数组

```shell
#定义一个数组的方法是在圆括号()中放置各个元素并使用空格隔开
month=("Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec")
#结合上面花括号用法中的构造序列,我们也可以这样定义数组
letter_combos=({a..z}{a..z})
#还可以这样定义一个数组,下面的数组按照升序依次包含了所有8位的二进制数
dec2bin=({0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1}{0..1})
#这个数组可以作为一个十进制数到8位二进制数的转换器.例如将十进制数25转换为二进制数,可以这样执行
echo ${dec2bin[25]}
```





## shell变量

### 查看linux系统中变量的方法

```shell
#显示当前shell中的所有变量
set/declare
#显示当前用户的环境变量
env
#显示当前导出成用户变量的环境变量，并显示变量的属性(是否只读)，按变量名称排序
export
#取消环境变量
unset
```

有些变量是shell自带的,不需要通过~/.bash_profile,~/.bashrc,/etc/bashrc等设置,比如IFS,RANDOM

通过`export 变量名`,可以把一个变量变成环境变量,子shell可以继承父shell的环境变量,但子shell对环境变量的修改不会影响到父shell的环境变量

#### declare用法

> 选项说明:
> -a	将后面的variable定义为数组 
>
> -i	将后面的variavle定义为整数数字 
>
> -x	用法与export一样,就是将后面的variable变成环境变量 
>
> -r	将一个variable的亦是设置成只读,读变量不可更改内容,也不能unset

#### set用法

set可以设置shell选项,用法见<<shell.md>>



### 内部字段分割字符IFS

IFS中的字符可以是空白符（空格、制表符、回车符）和非空白符

1.如果是空白符，则数据前后的空白符会被忽略；如果是非空白符，则不会被忽略；

2.如果有多个连续的空白符，则并列成为一个分隔符，而多个连续的非空白符，则被认为是多个分隔符，如：

```shell
lzh@lzh-ws:test$ IFS=a;test=babaabbaaabbb;echo $test
b b  bb   bbb
```

第一个b和第二个b之间有一个空格，因为a转换成分割的空格了，第二个b和第三个bb之间有两个空格，不是因为他们中间有两个aa，是因为他们中间的第一个a被转换成分隔的空格了，第二个a没有转换是一个空格，下面的脚本例子更好理解：

```shell
#!/bin/bash
test="babaabbaaabbb";
IFS=a;
for i in $test
do echo value=$i
done
```

结果:

```shell
value=b
value=b
value= 
value=bb
value= 
value= 
value=bbb
```

第二个aa中的第一个a用来表示分割，第二个a转换成空格了

3.字符前默认有一个空白，如果一个字符前有一个非空白符的分隔符，此非空白符可以输出，如：

```shell
#!/bin/bash
out()
{
for arg
do
	echo "[$arg]"
done
}
echo "IFS=:"
IFS=:
VAR=":a::b:c:::"
out $VAR
```

结果:

```shell
IFS=:
[]
[a]
[]
[b]
[c]
[]
[]
```



### 函数变量

**从shellshock出现后,后来版本的bash好像取消了函数变量功能**

如:

```shell
X='() { echo test;}'
```

此函数变量在当前shell中可以用set查询到，但不生效，只有把此函数变量定义为全局变量，在他的子shell中才能生效。



### 数组变量

```shell
declare -a 数组名
```

可以不定义直接对数组元素逐个赋值

```shell
数组名[0]=aaa
数组名[1]=bbb
```

也可以不定义对数组组合赋值

```shell
数组名=(值1 值2 ... 值n)
```



### 变量的应用

#### echo不显示变量中的多个空格?

```shell
lzh@lzh-ws:~$ tmp="a    b    d"
lzh@lzh-ws:~$ echo $tmp
a b d
```

解决办法是给变量加上双引号""

```shell
lzh@lzh-ws:~$ echo "$tmp"
a    b    d
```

echo $tmp的执行过程为：

1.替换变量：echo a    b    d

2.执行命令：echo a    b    d

3.按IFS划分echo命令之后的参数a, b, d

所以打印出来就是a b d,多个空格只显示了一个。



### linux预先定义的特殊变量

`$#`	表示命令行（表示正在工作的shell，脚本就是脚本工作的子shell）上参数的个数

`$?`	表示上一条命令执行后的返回值

`$$`	表示当前进程的进程号

`$!`	表示上一个后台命令对应的进程号

`$-`	表示当前shell设置的执行标志名组成的字符串

`$*`	表示在命令行中实际给出的所有实参字符串

`$@`	与`$*`作用相同，但是`$*`和`$@`不同，`$*`表示所有参数组成一个字符串，`$@`表示每个参数和参数中的空格/分隔符分开多个的字符串

`$0`	表示当前shell

`$_`	表示上一条命令的最后一个字符，和`!$`不同，`!$`显示的是上一条命令在显示器上打印出的最后一个字符，不考虑alias，如执行alias ll=ls -l，再执行ll，再执行echo $_，显示的是-l，如果执行的是echo !$，则为ll。（在<<linux历史命令.md>>文件中也有介绍）



### 常见的shell变量

$SHELL	表示当前shell类型

$USER	当前登录者

$LOGNAME	当前登录者

$PATH	各命令的执行位置

$HOSTNAME	主机名

$0	查看是否为登陆shell，带-的为登陆shell，不带-的为非登陆shell

$-	查看shell属性（himBH，shell节有少许解释）

$?	上一条指令是否成功执行，如果为0既成功执行，否则未成功

$$	显示当前shell的pid

$RANDOM	产生一个0～32767之间的随机数（应该不包括0和32767，待验证）可以通过$((RANDOM%10+1))来表示一个1~10的随机数





### 变量内容赋值的另一种方式

| 变量设置方式     | str没设定              | str为空字符            | str为非空字符     |
| ---------------- | ---------------------- | ---------------------- | ----------------- |
| var=${str-expr}  | var=expr               | var=                   | var=$str          |
| var=${str:-expr} | var=expr               | var=expr               | var=$str          |
| var=${str+expr}  | var=                   | var=expr               | var=expr          |
| var=${str:+expr} | var=                   | var=                   | var=expr          |
| var=${str=expr}  | str=expr  var=expr     | str不變 var=           | str不變var=$str   |
| var=${str:=expr} | str=expr var=expr      | str=expr  var=expr     | str不變  var=$str |
| var=${str?expr}  | expr輸出至stderr（注） | var=                   | var=$str          |
| var=${str:?expr} | expr輸出至stderr（注） | expr輸出至stderr（注） | var=$str          |

注:实验中终端会提示错误,尝试用错误输出重定向到一个文件中,但文件无结果,没有错误输出,原因未知,格式如下:

```shell
lzh@lzh-ws:~$ var=${str?expr}
bash: str: expr
```























